var fs = require('fs');
var someHumanData = require('./someHumanData').someHumanData;
var modulesByTypes = require('./someHumanData').modulesByTypes;
var specialModuleData = require('./someHumanData').specialModuleData;
var prettier = require('prettier');
const csv = require('csv-parser');

const outputFileName = './data/moduleData.js';

Promise.all([
  csvToJsonPromise('./raw_data/modules.csv'),
  csvToJsonPromise('./raw_data/projectiles.csv'),
  csvToJsonPromise('./raw_data/loc_strings_en.csv', ['key', 'value']),
]).then(([modulesDataRaw, projectilesDataRaw, localisation]) => {
  let modulesData = getModuleInfo(modulesDataRaw);
  modulesData = addRocketInfo(modulesData, projectilesDataRaw);
  modulesData = addDroneInfo(modulesData);
  modulesData = addTranslations(modulesData, someHumanData);
  let fullModulesData = addSpecialModulesData(modulesData, specialModuleData);

  saveToFile(outputFileName, fullModulesData);
});

function csvToJsonPromise(path, headers) {
  let result = [];

  return new Promise((resolve, reject) => {
    const stream = fs
      .createReadStream(path)
      .pipe(csv(headers))
      .on('data', (row) => {
        result.push(row);
      })
      .on('finish', function(event) {
        resolve(result);
      });

    setTimeout(() => {
      reject(`timeout read `, path);
    }, 3000);
  });
}

function saveToFile(filePath, modulesData) {
  const content = `
// generated by ${__filename} 
// at ${new Date().toString()}

var modulesData = ${JSON.stringify(modulesData, true, 2)}

var modulesByTypes = ${JSON.stringify(modulesByTypes, true, 2)}

const allModuleKeys = [
  ...modulesByTypes.trade,
  ...modulesByTypes.mining,
  ...modulesByTypes.weapon,
  ...modulesByTypes.shield,
  ...modulesByTypes.support
];

module.exports = {
  modulesData,
  allModuleKeys,
  modulesByTypes
};
`;

  fs.writeFileSync(
    filePath,
    prettier.format(content, {
      parser: 'babel',
      trailingComma: 'es5',
      tabWidth: 2,
      semi: true,
      printWidth: 500, // чтоб массивы выстраивались в одну линию
      jsxSingleQuote: true,
      jsxBracketSameLine: false,
      arrowParens: 'always',
      bracketSpacing: true,
      singleQuote: true,
    })
  );
}

function removeFields(obj, fields) {
  const cleanObj = {};

  for (let key in obj) {
    if (fields.indexOf(key) === -1) {
      cleanObj[key] = obj[key];
    }
  }

  return cleanObj;
}

function getNonEmptyString(obj) {
  const cleanObj = {};

  for (let key in obj) {
    if (obj[key] !== '') {
      cleanObj[key] = obj[key];
    }
  }

  return cleanObj;
}

function squooshNonArrays(moduleData) {
  const newModuleData = {};

  Object.keys(moduleData).forEach((key) => {
    if (moduleData[key][1] === '' || moduleData[key].length === 1) {
      newModuleData[key] = moduleData[key][0];
    } else {
      newModuleData[key] = moduleData[key];
    }
  });

  return newModuleData;
}

function addTranslations(modulesData, someHumanData) {
  modulesData = { ...modulesData };

  Object.keys(modulesData).forEach((key) => {
    modulesData[key].engName = someHumanData[key].eng;
    modulesData[key].engDescription = ``;
  });

  return modulesData;
}

function addSpecialModulesData(modulesData, specData) {
  modulesData = { ...modulesData };

  Object.keys(specData).forEach((key) => {
    modulesData[key] = specData[key];
  });

  return modulesData;
}

function addDroneInfo(modulesData) {
  modulesData.AlphaDrone = {
    ...modulesData.AlphaDrone,
    HP: ['400', '1200', '2500', '3500', '4500', '5500', '6500', '7500', '8500', '10000', '12000', '14000'],
    Speed: ['175', '175', '175', '175', '175', '175', '175', '175', '175', '175', '175', '175'],
    DPS: ['120', '120', '120', '120', '120', '120', '120', '120', '120', '120', '120', '120'],
  };
  modulesData.MiningDrone = {
    ...modulesData.MiningDrone,
    HP: ['1000', '1500', '2200', '3000', '4000', '5000', '6000', '7000', '8000', '9000'],
    HydrogenCapacity: ['140', '160', '180', '200', '220', '250', '280', '310', '350', '400'],
    MiningSpeed: ['29.1', '33.3', '37.5', '41.7', '45.8', '52.2', '58.8', '65.2', '74.1', '85.7'],
    Speed: ['200', '200', '200', '200', '200', '200', '200', '200', '200', '200'],
  };

  return modulesData;
}

function addRocketInfo(modulesData, projectilesData) {
  const rocketsData = getModuleInfo(projectilesData);

  function getRockerData(rocketData) {
    const data = {
      Speed: Array.from({ length: rocketData.HP.length }, () => rocketData.Speed),
      HP: rocketData.HP,
      Damage: rocketData.Damage,
      DamageRange: rocketData.DamageRange,
    };

    if (rocketData.DamageWhenNeutralized) {
      data.DamageWhenNeutralized = rocketData.DamageWhenNeutralized;
    }

    if (rocketData.DamageRangeWhenNeutralized) {
      data.DamageRangeWhenNeutralized = rocketData.DamageRangeWhenNeutralized;
    }

    return data;
  }

  modulesData.DartLauncher = {
    ...modulesData.DartLauncher,
    ...getRockerData(rocketsData.Dart),
  };

  modulesData.HydroRocket = {
    ...modulesData.HydroRocket,
    ...getRockerData(rocketsData.HydroRocket),
  };

  modulesData.AlphaRocket = {
    ...modulesData.AlphaRocket,
    ...getRockerData(rocketsData.Alpha),
  };

  modulesData.DeltaRocket = {
    ...modulesData.DeltaRocket,
    ...getRockerData(rocketsData.Delta),
  };

  modulesData.OmegaRocket = {
    ...modulesData.OmegaRocket,
    ...getRockerData(rocketsData.Omega),
  };

  return modulesData;
}

function getModuleInfo(modulesData) {
  let modulesInfo = {};

  let currentName = null;
  let currentMatterKeys = null;

  const trash = [
    'ActivationType',
    'ShowWSInfo',
    'HideSelection',
    'SlotType',
    'ClientActivationFx',
    'SustainedFX',
    'WeaponFx',
    'ActivateFX',
    'ActivateFXStaysInPlace',
    'WeaponEffectType',
    'ScaleEffectsWithZoom',
    'AllowedStarTypes',
    'DoNotAward',
    'TeleportToTradeStation',
    'MaxImpulse',
    'StopCountdownOnDisable',
    'AdditionalWaypoint',
    'Model',
    'ImpactFX',
    'DestroyedFX',
    'LaunchFX',
  ];

  const matterFields = [`ActivationPrepBS`, `ActivationPrep`, `ActivationPrepWS`];

  modulesData.forEach((modData) => {
    if (+modData.Hide) {
      return;
    }

    if (modData.Name && currentName !== modData.Name) {
      currentName = modData.Name;
      currentMatterKeys = Object.keys(removeFields(getNonEmptyString(modData), trash));

      modulesInfo[currentName] = {
        id: currentName,
        maxLevel: 0,
      };

      currentMatterKeys.forEach((key) => {
        modulesInfo[currentName][key] = [];
      });
    }

    modulesInfo[currentName].maxLevel++;

    currentMatterKeys.forEach((key) => {
      if (matterFields.includes(key) && !modData[key]) {
        // параметры, которые мы хотим сделать принудительно табличными
        const firstVal = modulesInfo[currentName][key][0];
        modulesInfo[currentName][key].push(firstVal);
      } else {
        modulesInfo[currentName][key].push(modData[key]);
      }
    });
  });

  Object.keys(modulesInfo).forEach((key) => {
    modulesInfo[key] = squooshNonArrays(modulesInfo[key]);
  });

  return modulesInfo;
}
